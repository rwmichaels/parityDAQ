#  -*- c -*-
# 
#  Minimal test of HAPPEX ADCs, with VME timing board,
#  and a scaler.
#
#    Bob Michaels / Antonin Vacheret  Oct 2000
# 

readout list VME1
maximum 10240,100
vme readout
/* All the memory maps of VME modules are defined in module_map.h  */
include "../module_map.h"
/* User strings to control some readout */
include "usrstrutils.c"

# default timing board DAC values
const  DEF_DAC12   =    0       /* output voltage = 0 */
const  DEF_DAC16   =    32767   /* output voltage = 0 */
# all other timing parameters are set in separate utilities


# Number of scaler
const NSCALER = 1
# Switch all this, depending on which kind of scaler 
# Must be consistent with preprocessor switch below (TYPE_SIS3800, etc)
const SCALER0 = hex a40000

# if LINUXHOST=1(0) host is linux(not)
const LINUXHOST = 1
const TRIG_ADDR = hex 0ad0

const FIFO_EMPTY = hex 100

const OPORT_BUSY = 1   /* bit 1 = busy output */
const OPORT_INB  = 2   /* bit 2 = inhibit output for other 2 DAQs */
const OPORT_LNE  = 4   /* bit 3 = LNE for scaler FIFO */
int oport_state;   /* output port state (global variable) */

static int noscaler, bmw, tbreadout;

unsigned short ranny[65535];  /* array of random integers */

extern int bigendian_out;
static FUNCPTR handlerPtr;
VOIDFUNCPTR isr;

# Switch here if picking a different kind of scaler
# Either TYPE_SIS3801, TYPE_SIS3800, TYPE_LEC1151, or TYPE_CAEN560 
# may be one, not all 1.
%% 
#undef TYPE_CAEN560
#undef TYPE_SIS3800 
#undef TYPE_LEC1151 
#define TYPE_SIS3801
#ifdef TYPE_SIS3801
volatile struct fifo_scaler *pscaler[NSCALER];
#define DATA_MASK 0xffffff
#endif
#ifdef TYPE_SIS3800
volatile struct SIS3800 *pscaler[NSCALER];
#endif
#ifdef TYPE_LEC1151
volatile struct lecroy_1151_scaler *pscaler[NSCALER];
#endif
#ifdef TYPE_CAEN560
volatile struct caen_v560_scaler *pscaler[NSCALER];
#endif

%%

begin download

# Sending data to Little-Endian EB
%%  
  int i,j,tmode,mode,res;
  unsigned short temp;
  unsigned long laddr;
  extern void srand();
  extern int rand();
  int chkcsr, retry;
  CODA_RUN_IN_PROGRESS = 0;

  if (LINUXHOST) {
      printf("Assuming EB is on a Little-Endian cpu\n");      
      bigendian_out = 0;
  }
init_strings();

noscaler=0;bmw=0;tbreadout=0;
noscaler  = getflag(NOSCALER);   /* No scaler used for this crate */
bmw       = getflag(BMW);        /* Readout Beam Modulation Words */
tbreadout = getflag(TBREADOUT);  /* Write Timing Board config to file */

/* Printout User String Configuration */
printf("*** User String Configuration ***\n");
if(noscaler == 0) {
  printf("WILL readout scaler: %d\n",noscaler);
} else {
  printf("Will NOT readout scaler: %d\n",noscaler);
}
if(bmw==1) {
  printf("WILL readout Beam Modulation Words: %d\n",bmw);
} else {
  printf("Will NOT readout Beam Modulation Words: %d\n",bmw);
}
if(tbreadout==1) {
  printf("WILL write timing board config to file: %d\n",tbreadout);
} else {
  printf("Will NOT write timing board config to file: %d\n",tbreadout);
}


/* Setup Device Pointers */

/* TIR Pointer */
  res = sysBusToLocalAdrs(0x29,TRIG_ADDR,&laddr);
  if (res != 0) {
     printf("Error in sysBusToLocalAdrs res=%d \n",res);
     printf("ERROR:  TIR POINTER NOT INITIALIZED");
  } else {
     printf("Trigger Interface address = 0x%x\n",laddr);
     tir[1] = (struct vme_tir *)laddr;
  }

/* ADC Configuration */
// show default configurations
  showHAPADC(-1);

/* Timing Board configuration */
// all timing configuration should be done in separate routines, to avoid ambiguity
  setDACHAPTB(1,DEF_DAC12);
  setDACHAPTB(2,DEF_DAC16);
  dumpRegHAPTB();

if(noscaler == 0) {
  /* switch this, depending on which kind of scaler */
#ifdef TYPE_SIS3801
  res = sysBusToLocalAdrs(0x39,SCALER0,&laddr);
  if (res != 0) {
    printf("Error in sysBusToLocalAdrs res=%d \n",res);
    printf("ERROR:  SCALER POINTER NOT INITIALIZED");
  } else {
    printf("SIS3801 Scaler address = 0x%x\n",laddr);
    pscaler[0] = (struct fifo_scaler *)laddr;
  }
  
  pscaler[0]->reset=1;
  pscaler[0]->csr=0xff00fc00;
  pscaler[0]->clear=1;
  pscaler[0]->enable=1;
  mode = 2;
  tmode = mode << 2;
  pscaler[0]->csr=0x00000C00;  /* clear Mode bits to Mode 0*/
  pscaler[0]->csr=tmode;       /* set new Mode */
  pscaler[0]->csr=0x10000;     /* Enable External Next Clock */
  pscaler[0]->csr=0x40000;     /* Enable External Disable */
#endif  
#ifdef TYPE_SIS3800
  pscaler[0] = (struct SIS3800 *) SCALER0;
  for (i=0; i < NSCALER; i++) {
    pscaler[i]->reset = 1;
    pscaler[i]->csr = 0x7000fd00;
    pscaler[i]->clear = 1;
    pscaler[i]->enclk = 1;
    pscaler[i]->csr=0x00000C00;  /* clear Mode bits to Mode 0*/
    mode = 1;
    pscaler[i]->csr=(mode<<2);       /* set mode */
  }
#endif
#ifdef TYPE_LEC1151
  pscaler[0] = (struct lecroy_1151_scaler *) SCALER0;
  for (i=0; i < NSCALER; i++) {
    pscaler[i]->reset = 0;
  }
#endif
#ifdef TYPE_CAEN560
  pscaler[0] = (struct caen_v560_scaler *) SCALER0;
  for (i=0; i < NSCALER; i++) {
    pscaler[i]->ClrR = 0;
    temp = pscaler[i]->clrVETOR;
  }
#endif
}

srand(9421);       /* seed random num generator */
/* Fill Random Integer Array */
for (j=0;j<65535;j++) {
  /* Generate random integers from 2048 to 63488 */
  ranny[j] = 2048 + (unsigned short) (61440.0*rand()/(32768+1.0));
}


/* Clear TIR */
   tir[1]->tir_csr = 0x80;
/* inhibit bit */
   oport_state |= OPORT_INB;   
   tir[1]->tir_oport=oport_state;

%%

  log inform "User Download Executed"

end download
    
begin prestart

  log inform "Entering User Prestart"

  init trig source VME


%%
/* The following replaces the line
   "link async trig source VME 1 to partrig and partrig_done"
   which was erroneously clearing the TIR outputs */

    { void partrig (); void partrig_done (); 
      doneRtns[trigId] = (FUNCPTR) ( partrig_done ) ; 
      trigRtns[trigId] = (FUNCPTR) ( partrig ) ; 
      Tcode[trigId] = ( 1 ) ; ttypeRtn = tirttype ; 
      {  printf("Linking async VME trigger to id %d \n", trigId ); 
         VME_handlers = ( trigId ); VME_isAsync = 1;
         handlerPtr = (FUNCPTR) 0;
         if (handlerPtr) free(handlerPtr);
         tir[1]->tir_vec = 0xec ;
         if((intDisconnect(((VOIDFUNCPTR *) ( 0xec  )) ) !=0))
               printf("Error disconnecting Interrupt\n");
         isr = VME_int_handler;
         intConnect(((VOIDFUNCPTR *) ( 0xec  )) ,isr,0);
      };
      trigId++;
     };  
%%
  event type 1 then read VME 1

%%

  if(tbreadout==1) {
    /* Send timing board information to ~apar/db/timebrd/timebrd.cfg */
    
    int fdbfile;
    
    fdbfile=fopen("~apar/db/timebrd/timebrd.cfg","w");
    fprintf(fdbfile,"# Timing board information:\n# Integrate Time = %.2f ms, Ramp Delay = %.2f us\n\ \ \ \ oversamp %d ",
	    (double)getIntTimeHAPTB()*0.0025,
	    (double)getRampDelayHAPTB()*2.5,
	    (int)getOverSampleHAPTB()+1);
    fclose(fdbfile);
  }

%%

  log inform "User Prestart Executed"

end prestart

begin end

  CDODISABLE(VME,1,0);

# inhibit bit
  oport_state |= OPORT_INB;   
  tir[1]->tir_oport=oport_state;

/* Disable LNE Flag */
   oport_state = oport_state & 0xfb;
   tir[1]->tir_oport=oport_state;

  CODA_RUN_IN_PROGRESS = 0;

  log inform "User End Executed"

end end

begin pause

  CDODISABLE(VME,1,0);
  log inform "User Pause Executed"

end pause

begin go
  
  log inform "Entering User Go Go (bob)"
  
%% 
  int i;
  unsigned short temp;

if(noscaler == 0) {
#ifdef TYPE_SIS3801
  /* SIS3801 */
  for (i=0; i<NSCALER; i++) {
    pscaler[i]->csr = 0x1000000; /* disable LNE */
    pscaler[i]->clear = 1;
    pscaler[i]->next = 1;  /* flush FIFO */
    pscaler[i]->csr = 0x10000; /* enable LNE */
  }
#endif
#ifdef TYPE_SIS3800
  /* SIS3800 */
  for (i=0; i<NSCALER; i++) pscaler[i]->clear = 1;
#endif
#ifdef TYPE_LEC1151
  /* LeCroy 1151 */
  for (i=0; i<NSCALER; i++) pscaler[i]->reset = 1;
#endif
#ifdef TYPE_CAEN560
  for (i=0; i < NSCALER; i++) {
    pscaler[i]->ClrR = 0;
    temp = pscaler[i]->clrVETOR;
  }
#endif
}

/* remove the inhibit */
%%  
   log inform "wait... will remove inhibit"
   taskDelay(600);
   log inform "about to remove inhibit"
   oport_state = oport_state & 0xfd; 
   tir[1]->tir_oport=oport_state;

/* Enable LNE Flag */
   oport_state |= OPORT_LNE;
   tir[1]->tir_oport=oport_state;

  CDOENABLE(VME,1,0);
  CODA_RUN_IN_PROGRESS = 1;

end go

begin trigger partrig

variable i,j
unsigned long ltest;
static int dac16val=DEF_DAC16;
static int dac12val=DEF_DAC12;
static int maxdac16=65535;
static int maxdac12=4095;
static int ncnt=0;
int timeout;
unsigned short rannum;
int tir_dat;
static int k;
static int rannyint;
int errstat;
unsigned long sdata[NSCALER*32*12];
int pulseclean;
int localBMWobj;
int localBMWval;
int localBMWcycnum;

int* intpointer;

/* Enable BUSY Flag */
oport_state |= OPORT_BUSY;
tir[1]->tir_oport=oport_state;

rol->dabufp = (long *)0;
open event type EVTYPE of BT_UI4

ncnt++;

%%
if(bmw==1) {
  //////////////////////////////////////////////////
  //
  // BMW: early in readout! (the bmw process in asynchronous,
  //      and we don't want nuthin' to change before we see it
  //
  //////////////////////////////////////////////////
  localBMWobj = bmw_object;
  localBMWval = bmw_value;
  localBMWcycnum = bmw_cycle_number;
  
  //  record if event was unclean for any portion of pulse
  pulseclean = bmw_clean_pulse;
  
  //  if pulse was at some point unclean, but ended clean, prepare
  //  next pulse to be seen as clean
  if (!(pulseclean==1) && (bmw_clean==1)) bmw_clean_pulse=1;
}

if(noscaler == 0) {
  //////////////////////////////////////////////////
  
  /* Put scalers at beginning of readout */
  
#ifdef TYPE_SIS3801
  errstat = 0;
  for (i = 0; i <NSCALER; i++) {
    timeout = 0;
    while ( (pscaler[i]->csr&FIFO_EMPTY) != FIFO_EMPTY && timeout++ < 10) {
      for (j = 0; j < 32; j++) {
	sdata[i*32+j] = ((int)pscaler[i]->fifo[0])&DATA_MASK;  
      }
    }
  }
  if (timeout > 1) errstat = 1;
  *rol->dabufp++ = 0xfffca000 + NSCALER + (errstat<<4);   /* Header for scaler */
  for (i = 0; i <NSCALER; i++){
    for (j = 0; j < 32; j++) {
      *rol->dabufp++ = sdata[i*32+j];
    }
  }
#else 
  
  *rol->dabufp++ = 0xfffca000 + NSCALER;   /* Header for scaler */
  
#endif
#ifdef TYPE_SIS3800
  /* SIS3800 scaler */
  for (i=0; i < NSCALER; i++) {
    for (j=0; j < 32; j++) {
      *rol->dabufp++ = pscaler[i]->readCounter[j];
    }
  }
  /* FOR TESTING PURPOSES... clear scalers after counters are read out */
  for (i=0; i<NSCALER; i++) pscaler[i]->clear = 1; 
#endif
#ifdef TYPE_LEC1151
  /* LeCroy 1151 scaler */
  for (i=0; i < NSCALER; i++) {
    for (j=0; j < 16; j++) {
      *rol->dabufp++ = pscaler[i]->scaler[j];
    }
    for (j=0; j < 16; j++) *rol->dabufp++ = 0;  
  }
#endif
#ifdef TYPE_CAEN560
  /* CAEN model 560 scaler */
  for (i=0; i < NSCALER; i++) {
    for (j=0; j < 16; j++) {
      *rol->dabufp++ = pscaler[i]->CntR[j];
    }
    for (j=0; j < 16; j++) *rol->dabufp++ = 0;  
  }
#endif
}  

*rol->dabufp++ = 0xffadc000 + ADC_NUMSLOTS;   /* Header for ADC */  
//readoutHAPADC(rol->dabufp,ADC_NUMSLOTS-1);
for (i=0; i < ADC_NUMSLOTS; i++) rol->dabufp = readoutHAPADC(rol->dabufp,i);
//for (i=ADC_NUMSLOTS-1; i>=0; i--) rol->dabufp = readoutHAPADC(rol->dabufp,i);


*rol->dabufp++ = 0xffdaf000;    /* Header for misc. info of event */
tir_dat = tir[1]->tir_dat;
*rol->dabufp++ = tir_dat & 0xfff;
*rol->dabufp++ = 0xfffbd000;    /*  Header for timing board info */
*rol->dabufp++ = getDataHAPTB();
*rol->dabufp++ = getRampDelayHAPTB();
*rol->dabufp++ = getIntTimeHAPTB();
*rol->dabufp++ = (getOverSampleCurrentHAPTB() << 8) + getOverSampleHAPTB();
*rol->dabufp++ = getDACHAPTB(2); /* DAC16 */
*rol->dabufp++ = getDACHAPTB(1); /* DAC12 */

if(bmw==1) {
  *rol->dabufp++ = pulseclean;  //record in bmw says entire pulse was clean
  *rol->dabufp++ = localBMWobj; //record the last-moved object (from beginning of readout)
  *rol->dabufp++ = localBMWval; // record the value of the last-moved object
  *rol->dabufp++ = localBMWcycnum; // record the number of this supercycle 
}

for (i = 0; i < ADC_NUMSLOTS; i++) {  
  if (usesDACHAPADC(i)==1) {
    // lookup table of random numbers
    rannum = ranny[rannyint];   /* rand goes from 0 to 32768 */
    rannyint++;
    if (rannyint>65534) rannyint=0;
    
    setDACHAPADC(i,rannum);
  
    // alternate methods of choosing dac noise values
    //
    //       rannum = 2048 + rand();   /* rand goes from 0 to 32768 */
    //
    //        if (rannum % 2 == 0){
    //          dac_count[i] = 5000;
    //        } else {
    //          dac_count[i] = 60000;
    //        }             
    //
  }
}


// This is for tests using tboard dac

/*  rannum = 2000 + rand();*/

//  if (dac16val >= maxdac) dac16val = 18000;
//  //  test for differences measurements...    
//      if (rannum % 2 == 0){
//      dac16val = 49000;  
//      } else{
//      dac16val = 50000; 
//      }    
//  setDACHAPTB(2,dac16val);


/* V/F and/or ADC test.  Increment dacs after last sample in helicity window
   recall: Last sample has OS=0 in these new timing boards */

if(getOverSampleCurrentHAPTB()==0) {
  dac12val = dac12val + 2; 
  dac16val = dac16val + 10; 
} 
  if (dac12val >= maxdac12) dac12val = 0;
  setDACHAPTB(1,dac12val);
  getDACHAPTB(1);
  if (dac16val >= maxdac16) dac16val = 32767;
  setDACHAPTB(2,dac16val);
  getDACHAPTB(2);

/* Disable BUSY Flag */
oport_state = oport_state & 0xfe;
tir[1]->tir_oport=oport_state;

%%

close event

end trigger

begin done partrig

end done

begin done

# Acknowledge tir register
poolEmpty = 0;
tirtack(0);

end done

begin status

end status

