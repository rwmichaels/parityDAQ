# 
#  Readout list for SIS3320 ADC.
#  The 1st paramter of "maximum" is >= max bytes of readout.
#
#    Bob Michaels 

readout list VME1
maximum 250000,8
vme readout
# if LINUXHOST=1(0) host is linux(not)
const LINUXHOST = 1
const TIR_ADDR = 0xed0

# restriction on buffer due to memory limits 50K ok, 80not (for max 250K,8)
const MAXBUF = 50000

include "usrstrutils.c"

static int use_thresh;
static int get_samples;

extern int bigendian_out;


begin download

  unsigned long res, laddr;

# Sending data to Little-Endian EB

%%  
  init_strings();
  get_samples = getflag(FADCSAMP);
  use_thresh = getflag(FADCTHRESH);
  printf("FADC DAQ setup.  get_samples = %d    use_thresh  %d\n",
              get_samples, use_thresh);

  if (LINUXHOST) {
      printf("Assuming EB is on a Little-Endian cpu\n");      
      bigendian_out = 0;
  }

  res = (unsigned long) sysBusToLocalAdrs(0x29,TIR_ADDR,&laddr);
  if (res != 0) {
     printf("Error in sysBusToLocalAdrs res=%d \n",res);
  } else {
     printf("Trigger Interface address = 0x%x\n",laddr);
     tir[1] = (struct vme_tir *)laddr;
  }
  printf("tir[1] address = 0x%x\n",tir[1]);



%%
  
  log inform "User Download Executed (vme_sis3320.crl) "

end download
    
begin prestart

  log inform "Entering User Prestart"

  init trig source VME
  link async trig source VME 1 to partrig and partrig_done
  event type 1 then read VME 1

  log inform "Setting up SIS3320 board"

  sis3320Reset(0);

  sis3320DefaultSetup(0);
%%
 // accumulate for data > threshold for positive polarity (or < thres, neg)
 sis3320SetThresh(0,0,-1,0);
 if (use_thresh) sis3320SetThresh(0,0,0,1900);
 
 // Note, the DAC settings correspond to the pedestals approximately:
 //   DAC     ped
 //  30000    155
 //  32000    500
 //  33100    688
 //  40600   ~2000  (midpoint)
 //  50000   ~3600 

  sis3320SetDac(0,41000);	

%%
  log inform "User Prestart Executed"

end prestart

begin end

  CDODISABLE(VME,1,0);
  sis3320SetRunFlag(0);
  log inform "User End Executed"

end end

begin pause

  CDODISABLE(VME,1,0);
  sis3320SetRunFlag(0);
  log inform "User Pause Executed"

end pause

begin go
  
  log inform "Entering User Go"
  ClrSIS3800();
  sis3320SetRunFlag(1);
  CDOENABLE(VME,1,0);

end go

begin trigger partrig
 
  variable ichan
  int icnt, buf_len, len, which_adc, which_chan;
  volatile unsigned short tir_dat;

  which_adc = 0;

  tir[1]->tir_oport=0x1;

  rol->dabufp = (long *)0;
  open event type EVTYPE of BT_UI4
  
%%

  sis3320Start(0);

  icnt = 0;
  while ( sis3320Finished(0) == 0 ) {
       if (icnt++ > 500000) break;
   }


  *rol->dabufp++ = 0xf3800000; 
  *rol->dabufp++ = Read3800(0xab1000,0); 
  *rol->dabufp++ = Read3800(0xab1000,1); 
  *rol->dabufp++ = Read3800(0xab1000,2); 
  *rol->dabufp++ = Read3800(0xab1000,3); 
  *rol->dabufp++ = Read3800(0xab1000,4); 
  *rol->dabufp++ = 0xfb0b4444;   
/* When standalone, get data from tir_dat; when TS-mode use tir_iport */
  tir_dat = tir[1]->tir_dat; 
  *rol->dabufp++ = (tir_dat & 0xfff);

  *rol->dabufp++ = 0xfa300000 + icnt;
  

  if(sis3320IsRunning() == 0 || icnt > 50000 ) { 
       *rol->dabufp++ = 0xfa300bad; 
  } else {
       buf_len = sis3320GetBufLength(0); 
       len = buf_len;
/* this line seems to crash: */
/* *rol->dabufp++ = sis3320_Sum_ADC_Channel (0, which_adc, 0, buf_len, 0); */
       if (len > MAXBUF) len = MAXBUF;
       *rol->dabufp++ = buf_len;
       *rol->dabufp++ = len;
       *rol->dabufp++ = sis3320GetAccum(0, (which_adc >> 1), which_adc%2, 0);
       *rol->dabufp++ = sis3320GetAccum(0, (which_adc >> 1), which_adc%2, 1); 

/*  readout only 1 channel  */
       if ( get_samples == 1 ) {
         which_chan = 0;
         *rol->dabufp++ = 0xfadc3300; 
         for (ichan = 0; ichan < len/2; ichan++) {
	   *rol->dabufp++ = sis3320GetData(0, which_adc, ichan, 0);
           *rol->dabufp++ = sis3320GetData(0, which_adc, ichan, 1);
        }
       }
  }
%%

  tir[1]->tir_oport=0x0; 

  close event

end trigger

begin done partrig

end done

begin done

# Acknowledge tir register
   CDOACK(VME,1,0);

end done

begin status

end status








